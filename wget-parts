#!/usr/bin/perl
use v5.12;

use LWP::Simple qw($ua);
$ua->conn_cache({});
$ua->timeout(30);

unlink ".part$$";

$SIG{HUP} =
$SIG{INT} =
$SIG{QUIT} =
$SIG{PIPE} =
$SIG{TERM} = sub {
	unlink ".part$$";
	exit 143; # 128 + SIGTERM
};

my $Timeout = 20;
my $Progress = 1<<20;

my $size = 0;
my $next = $size + $Progress;

$SIG{ALRM} = sub {
	if ($size + -s ".part$$" < $next) {
		warn "terminating";
		unlink ".part$$";
		exit 124; # like timeout(1)
	}
	$next = $size + -s _ + $Progress;
	alarm $Timeout;
};

alarm $Timeout;

use POSIX qw(sigprocmask SIG_BLOCK SIG_SETMASK);
my $sigset_old = POSIX::SigSet->new;
my $sigset_all = POSIX::SigSet->new;
$sigset_all->fillset;

sub readLine () {
	use Fcntl qw(LOCK_EX LOCK_UN);
	# STDIN cannot be locked with flock(2) in this way
	open my $dirfd, "<", "." or die;
	flock $dirfd, LOCK_EX or die "flock: $!";
	defined sigprocmask SIG_BLOCK, $sigset_all, $sigset_old
		or die "sigprocmask: $!";
	undef $_;
	while (sysread STDIN, my $c, 1) {
		if ($c eq "\n") {
			last if defined;
		}
		else {
			$_ .= $c;
		}
	}
	sigprocmask SIG_SETMASK, $sigset_old;
	flock STDIN, LOCK_UN;
	return length > 0;
}

sub resume ($) {
	my $url = shift;
	my $size = -s ".part$$";
	return unless $size >= 8192;
	open my $fh, ">>", ".part$$" or return;
	binmode $fh;
	my $r = $ua->get($url,
		Range => "bytes=$size-",
		":content_cb" => sub { print $fh $_[0] });
	return $r->code == 206;
}

my $rc;

while (readLine) {
	chomp;
	unless (m#^\w+://.+/([^\s/]+)\z#) {
		$rc = 1, warn "bad part: $_";
		next;
	}
	my ($url, $fname) = ($_, $1);
	next if -s $fname;
	my $r = $ua->get($url, ":content_file" => ".part$$");
	if ($r->is_success or resume $url) {
		$size += -s ".part$$";
		rename ".part$$", $fname or
		$rc = 1, warn "rename failed";
	}
	else {
		unlink ".part$$";
		$rc = 1, warn "get failed: $fname";
	}
}

exit $rc;
