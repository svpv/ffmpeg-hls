#!/usr/bin/perl
use v5.12;

# when dying, exit with 2
$SIG{__DIE__} = sub { $! = 2 };

use LWP::Simple qw($ua);
$ua->conn_cache({ total_capacity => 2 });
$ua->timeout(30);

unlink ".part$$";

$SIG{HUP} =
$SIG{INT} =
$SIG{QUIT} =
$SIG{PIPE} =
$SIG{TERM} = sub {
	unlink ".part$$";
	my $sig = shift;
	delete $SIG{$sig};
	kill $sig => $$;
	exit 143; # cannot happen
};

my $Timeout = 20;
my $Progress = 1<<20;

my $Size = 0;
my $Next = $Size + $Progress;

$SIG{ALRM} = sub {
	if ($Size + -s ".part$$" < $Next) {
		warn "terminating";
		unlink ".part$$";
		exit 124; # like timeout(1)
	}
	$Next = $Size + -s _ + $Progress;
	alarm $Timeout;
};

alarm $Timeout;

use POSIX qw(sigprocmask SIG_BLOCK SIG_SETMASK);
my $sigset_old = POSIX::SigSet->new;
my $sigset_all = POSIX::SigSet->new;
$sigset_all->fillset;

sub readLine () {
	use Fcntl qw(LOCK_EX LOCK_UN);
	# STDIN cannot be locked with flock(2) in this way
	open my $dirfd, "<", "." or die;
	flock $dirfd, LOCK_EX or die "flock: $!";
	defined sigprocmask SIG_BLOCK, $sigset_all, $sigset_old
		or die "sigprocmask: $!";
	undef $_;
	while (sysread STDIN, my $c, 1) {
		if ($c eq "\n") {
			last if defined;
		}
		else {
			$_ .= $c;
		}
	}
	sigprocmask SIG_SETMASK, $sigset_old;
	flock STDIN, LOCK_UN;
	return length > 0;
}

my $rc;

sub download_chunk ($$) {
	my ($url, $fname) = @_;
	my $right_size;
	$ua->add_handler(response_header => sub {
		my $r = shift;
		$right_size = $r->content_length if $r->code == 200;
	});
	my $r = $ua->get($url, ":content_file" => ".part$$");
	$ua->remove_handler("response_header");
	if ($r->code == 200) {
		return 1 if -s ".part$$" and (-s _ == $right_size or not $right_size);
		warn "$fname: " . (-s _ ? "wrong size" : "empty output");
		$rc ||= 1;
		return;
	}
	elsif ($r->is_success) {
		warn "$fname: ", $r->status_line;
		$rc ||= 1;
		return;
	}
	elsif ($r->code == 404) {
		warn "$fname: ", $r->status_line;
		$rc = 4;
		return;
	}
	my $size = -s ".part$$";
	if ($size < 8192 or not $right_size) {
		warn "$fname: ", $r->status_line;
		$rc ||= 1;
		return;
	}
	warn "$fname: resuming (got $size bytes)";
	open my $fh, ">>", ".part$$" or die "$fname: $!";
	binmode $fh;
	my $r = $ua->get($url,
		Range => "bytes=$size-",
		":content_cb" => sub { print $fh $_[0] or die "$fname: $!" });
	close $fh or die "$fname: $!";
	if ($r->code == 206) {
		return 1 if $right_size == -s ".part$$";
		warn "$fname: wrong size after resume";
		$rc ||= 1;
		return;
	}
	warn "$fname: resume failed: ", $r->status_line;
	$rc ||= 1;
	return;
}

my $err;

my $base = shift;

while (readLine) {
	chomp;
	unless (m#^\w+://#) {
		if ($base) {
			$_ = "$base/$_";
		}
		else {
			warn "no base for $_";
		}
	}
	unless (m#^\w+://.+/([^\s/]+)\z#) {
		$rc ||= 1;
		warn "bad part: $_";
		last if ++$err >= 4;
		next;
	}
	my ($url, $fname) = ($_, $1);
	next if -s $fname;
	my $r = $ua->get($url, ":content_file" => ".part$$");
	if (download_chunk $url, $fname) {
		$Size += -s ".part$$";
		rename ".part$$", $fname or die "$fname: $!";
		undef $err;
	}
	else {
		unlink ".part$$";
		last if ++$err >= 4;
	}
	# 404, won't be able to assemble
	last if $rc == 4;
}

exit $rc;
