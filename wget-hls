#!/bin/bash -efu

wGetO()
{
	wget=("$av0dir"/wget-progress "$1" wget)
	wopt=(--timeout 20 --tries 3)
	if ! "${wget[@]}" "${wopt[@]}" -q -O "$@"; then
		if [ -n "${http_proxy-}" ]; then
			update-uk-proxy --hls
			. uk_proxy.sh
		fi
		if ! "${wget[@]}" "${wopt[@]}" -nv -O "$@" &>$tmpdir/werr; then
			cat >&2 $tmpdir/werr
			return 1
		fi
	fi
}

DoubleCheck()
{
	local url="$1"; shift
	set -- "$1" $tmpdir/out{1,2}
	wGetO "$2" "$url"
	if cmp -s "$1" "$2"; then
		rm "$2"
	else
		wGetO "$3" "$url"
		if cmp -s "$1" "$3"; then
			rm "$2" "$3"
		elif cmp -s "$2" "$3"; then
			echo >&2 "${0##*/}: fixed $1"
			mv "$2" "$1"
			rm "$3"
		else
			echo >&2 "${0##*/}: cannot fix $1"
			rm "$1" "$2" "$3"
			false
		fi
	fi
}

remove_tmpdir()
{
	rm -r "$tmpdir"
	exit $1
}

tmpdir=$(mktemp -dt "${0##*/}.XXXXXXXX")
trap 'exit 143' HUP INT QUIT PIPE TERM
trap 'remove_tmpdir $?' EXIT

av0=$(readlink -ev "$0")
av0dir=$(dirname "$av0")

wGetStats()
{
	local n
	n=$(wc -l <$tmpdir/parts)
	set +f
	while :; do
		set -- *
		if [ "$*" = "*" ]; then
			set --
		fi
		printf '\r%s %*d/%d ' "${PWD##*/}" ${#n} $# $n
		sleep 1
	done
}

UpdateProxyArgs()
{
	local p=$1 loop=$2; shift 2
	local para=("$@")
	file= args=()
	local q f
	for q in "${para[@]}"; do
		f=uk_proxy$q.sh
		if [ "$p" = "$q" ]; then
			file=$f
			args+=(--file=$f)
			$loop
		else
			args+=(--not-file=$f)
		fi
	done
}

UpdateKidProxy()
{
	if [ -n "${http_proxy-}" ]; then
		local file args
		UpdateProxyArgs "$@"
		args+=(--hls --recheck --self-lock)
		until update-uk-proxy "${args[@]}"; do : recheck; done
		. "$file"
	fi
}

wGetKid()
{
	local b="$1" p="$2"; shift 2
	local para=("$@")
	UpdateKidProxy "$p" "break" "${para[@]}" </dev/null
	if "$av0dir"/wget-parts "$b"; then
		: good
	elif [ $? = 4 ]; then
		exit 4
	else
		while :; do
			UpdateKidProxy "$p" ":" "${para[@]}" </dev/null
			if "$av0dir"/wget-parts "$b"; then
				break
			elif [ $? = 4 ]; then
				exit 4
			fi
		done
		# this kid reads from stdin and cannot succeed
		false
	fi <&0 &
}

wGetParts()
{
	local statpid
	wGetStats & statpid=$!
	local try rc=
	local npara=2
	for try in {1..3}; do
		left=$(comm -23 <(perl -pe 's#^\w+://.*/##' $tmpdir/parts |sort) <(ls) |wc -l)
		if [ $left = 0 ]; then
			break
		elif [ $left -lt $npara ]; then
			npara=$left
		fi
		local para=('' $(seq 2 $npara))
		local p pids=()
		for p in "${para[@]}"; do
			# use either $1 or $2 as base URL
			b=$((1+(${p:-1}-1)%2))
			wGetKid "${!b}" "$p" "${para[@]}"
			pids+=($!)
		done <$tmpdir/parts
		rc=
		local pid
		for pid in ${pids[@]}; do
			wait $pid ||
			case $? in
				4) rc=4 ;;
				*) : ${rc:=1} ;;
			esac
		done
		if [[ -z $rc || $rc = 4 && $try -gt 1 ]]; then
			break
		fi
		# rotate base URLs
		set -- "$2" "$1"
	done
	kill $statpid
	wait
	return $rc
}

OUT=
time=
hlsdir=
ffmpeg=(nice -5 ffmpeg)

wGetHLS()
{
	m3u=$tmpdir/hls.out
	wGetO "$m3u" "$1"
	if [ "$(head -c7 "$m3u")" = '#EXTM3U' ]; then
		Clean()
		{
	perl -pi -le 'BEGIN{$base=shift} s/\r//g; s#^\Q$base\E/##' "${1%/*}" <"$2" >"$2"c
		}
		if [[ $1 == $2 ]]; then
			DoubleCheck "$1" "$m3u"
			Clean "$1" "$m3u"
		else
			n3u=$tmpdir/hls.put
			wGetO "$n3u" "$2"
			if ! cmp -s "$m3u" "$n3u"; then
				DoubleCheck "$1" "$m3u"
				DoubleCheck "$2" "$n3u"
			fi
			Clean "$1" "$m3u"
			Clean "$2" "$n3u"
			if ! cmp -s "$m3u"c "$n3u"c; then
				echo >&2 "${0##*/}: URLs provide different playlists"
				set -- "$1" "$1"
			fi
		fi
		# always hash original m3u - segment names can be very simple,
		# it is the directory name that makes the list of segments unique
		hlsdir=$(sha1sum <"$m3u")
		hlsdir=${TMPDIR:-/tmp}/hls-${hlsdir:0:20}
		mkdir -p "$hlsdir"
		cd "$hlsdir"
		if grep '^[^#]' "$m3u"c >$tmpdir/parts; then
			wGetParts "${1%/*}" "${2%/*}"
		fi
		perl -pe 's#^\w+://.*/##' "$m3u"c >.m3u
		OUT=$PWD/.m3u
	else
		# downloaded something else, will return it within tmpdir
		OUT=$m3u
	fi
	rc=
	"${ffmpeg[@]}" -v error -stats -i "$OUT" -f null - &>$tmpdir/fferr || rc=$?
	sed -i 's/\r/\n/g' $tmpdir/fferr
	time=$(sed -n '$s/^\(frame\|size\)=.* time=\([^ ]\+\) .*/\2/p' $tmpdir/fferr)
	sed -i '/^\(frame\|size\)=.* time=/d' $tmpdir/fferr
	tolera='non-existing SPS 0 referenced in buffering period
SPS unavailable in decode_picture_timing
Application provided invalid, non.monotonically increasing dts to muxer
Last message repeated'
	if grep -q -v "$tolera" $tmpdir/fferr; then
		echo >&2 "${0##*/}: rechecking"
	elif [ -n "$rc" ]; then
		# too bad, ffmpeg fails even without -xerror,
		# and we don't have any errors to recheck
		cat $tmpdir/fferr
		echo "${0##*/}: cannot proceed"
		return 1
	else
		return 0
	fi >&2
	if [ "$(head -c7 "$m3u")" = '#EXTM3U' ]; then
		local n=0
		while read -r part; do
			f=${part##*/}
			if ! [ -s "$f" ]; then
				echo >&2 "${0##*/}: missing $f (cannot happen)"
				false
			fi
			"${ffmpeg[@]}" -v error -i "$f" -f null - 2>&1 </dev/null |
				stdbuf -oL sed "s|\t| |g;s|^|$part\t|" &
			(( ++n < 2 )) || wait -n
		done <$tmpdir/parts >$tmpdir/parts.all-errors
		wait
		# if some error is encountered in more than half of the parts,
		# it's not a real error
		perl -pi -e 's/ @ 0x[0-9a-f]+\]/]/' $tmpdir/parts.all-errors
		sort -t$'\t' -u -k2,2 -k1,1 -o $tmpdir/parts.all-errors{,}
		cut -f2 $tmpdir/parts.all-errors |uniq -c |
			awk -v n=$n '(n==1||$1<=n/2){sub(" +[0-9]+ ","");print}' |
			sort -u >$tmpdir/parts.real-errors
		join -t$'\t' -12 -21 -o 1.1 $tmpdir/parts.{all,real}-errors >$tmpdir/parts.ck
		sort -u -o $tmpdir/parts.ck{,}
		while read -r part; do
			f=${part##*/}
			DoubleCheck "$part" "$f" </dev/null
		done <$tmpdir/parts.ck
	else
		DoubleCheck "$url" "$m3u"
	fi
	rc=
	"${ffmpeg[@]}" -xerror -v error -stats -i "$OUT" -f null - &>$tmpdir/fferr || rc=$?
	sed -i 's/\r/\n/g' $tmpdir/fferr
	time=$(sed -n '$s/^\(frame\|size\)=.* time=\([^ ]\+\) .*/\2/p' $tmpdir/fferr)
	sed -i '/^\(frame\|size\)=.* time=/d' $tmpdir/fferr
	# stream still corrupted?
	if grep -v "$tolera" $tmpdir/fferr; then
		echo "${0##*/}: cannot proceed"
		return 1
	elif [ -n "$rc" ]; then
		cat $tmpdir/fferr
		echo "${0##*/}: cannot proceed"
		return 1
	fi >&2
}

wGetHLS "${1:?}" "${2:-$1}" >&2
# returning something within tmpdir?
[ -n "$hlsdir" ] || trap - EXIT
echo "${time:-N/A}" "${OUT:?}"
