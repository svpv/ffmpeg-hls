#!/bin/bash -efu

wGetO()
{
	wget=("$av0dir"/wget-progress "$1" wget)
	wopt=(--timeout 20 --tries 3)
	if ! "${wget[@]}" "${wopt[@]}" -q -O "$@"; then
		if [ -n "${http_proxy-}" ]; then
			update-uk-proxy --hls
			. uk_proxy.sh
		fi
		if ! "${wget[@]}" "${wopt[@]}" -nv -O "$@" &>$tmpdir/werr; then
			cat >&2 $tmpdir/werr
			return 1
		fi
	fi
}

DoubleCheck()
{
	local url="$1"; shift
	set -- "$1" $tmpdir/out{1,2}
	wGetO "$2" "$url"
	if cmp -s "$1" "$2"; then
		rm "$2"
	else
		wGetO "$3" "$url"
		if cmp -s "$1" "$3"; then
			rm "$2" "$3"
		elif cmp -s "$2" "$3"; then
			echo >&2 "${0##*/}: fixed $1"
			mv "$2" "$1"
			rm "$3"
		else
			echo >&2 "${0##*/}: cannot fix $1"
			rm "$1" "$2" "$3"
			false
		fi
	fi
}

remove_tmpdir()
{
	rm -r "$tmpdir"
	exit $1
}

tmpdir=$(mktemp -dt "${0##*/}.XXXXXXXX")
trap 'exit 143' HUP INT QUIT PIPE TERM
trap 'remove_tmpdir $?' EXIT

av0=$(readlink -ev "$0")
av0dir=$(dirname "$av0")

wGetStats()
{
	local n
	n=$(wc -l <$tmpdir/parts)
	set +f
	while :; do
		set -- *
		if [ "$*" = "*" ]; then
			set --
		fi
		printf '\r%s %*d/%d ' "${PWD##*/}" ${#n} $# $n
		sleep 1
	done
}

UpdateProxyArgs()
{
	local p=$1 loop=$2; shift 2
	file= args=()
	local q f=uk_proxy.sh
	for q; do
		if [ $q -gt 1 ]; then
			f=uk_proxy$q.sh
		fi
		if [ $p = $q ]; then
			file=$f
			args+=(--file=$f)
			$loop
		else
			args+=(--not-file=$f)
		fi
	done
}

UpdateKidProxy()
{
	if [ -n "${http_proxy-}" ]; then
		local file args
		UpdateProxyArgs "$@"
		args+=(--hls --recheck)
		until update-uk-proxy "${args[@]}"; do : recheck; done
		. "$file"
	fi
}

KidJobs()
{
	# prints e.g. " 2 3 ", or "" for no jobs
	jobs |sed -n '/\//{s/^\[\([0-9]\+\)\].*/\1\n/;H};$g;$s/\n\+/ /gp'
}

ParaTry()
{
	local b1=$1 b2=$2; shift 2
	# launch kids
	local p b j2p=()
	for p; do
		UpdateKidProxy $p "break" "$@" </dev/null
		# use either $b1 or $b2 as base URL
		b=b$((1+($p-1)%2))
		"$av0dir"/wget-parts "${!b}" <&0 &
		# wGetStats is job number 1
		j2p[p+1]=$p
	done
	# wait and possibly relaunch kids
	local j kids nowkids
	kids=$(KidJobs)
	while [ -n "$kids" ]; do
		local kidrc=
		wait -n || kidrc=$?
		nowkids=$(KidJobs)
		if [ -z "$kidrc" ]; then
			kids=$nowkids
			continue
		fi
		# it's an error by now - note that the kids read from stdin
		# and cannot possibly "succeed" after restart
		rc=1
		# 404 Not Found aborts the try
		if [ "$kidrc" = 4 ]; then
			for j in $nowkids; do
				kill %$j
				wait %$j ||:
			done
			rc=4
			return
		fi
		# will restart, but who exited?
		for j in $kids; do
			case $nowkids in
				*" $j "*) j= ;;
				*) break ;;
			esac
		done
		p=${j2p[j]-}
		if [ -z "$j" ] || [ -z "$p" ]; then
			echo >&2 "${0##*/}: don't know who exited (cannot happen)"
			kids=$nowkids
			continue
		fi
		UpdateKidProxy $p ":" "$@" </dev/null
		b=b$((1+($p-1)%2))
		"$av0dir"/wget-parts "${!b}" <&0 &
		kids=$(KidJobs)
		unset j2p[j]
		j=${kids% }
		j=${kids##* }
		j2p[j]=$p
	done
}

wGetParts()
{
	wGetStats &
	local try rc=
	local npara=2
	for try in {1..3}; do
		left=$(comm -23 <(perl -pe 's#^\w+://.*/##' $tmpdir/parts |sort) <(ls) |wc -l)
		if [ $left = 0 ]; then
			break
		elif [ $left -lt $npara ]; then
			npara=$left
		fi
		rc=
		local para=$(seq 1 $npara)
		ParaTry "$1" "$2" ${para:?} <$tmpdir/parts
		if [ -z "$rc" ]; then
			break
		fi
		# rotate base URLs
		set -- "$2" "$1"
	done
	kill %1
	wait
	return $rc
}

OUT=
time=
hlsdir=
ffmpeg=(nice -5 ffmpeg)

wGetHLS()
{
	m3u=$tmpdir/hls.out
	wGetO "$m3u" "$1"
	if [ "$(head -c7 "$m3u")" = '#EXTM3U' ]; then
		Clean()
		{
	perl -pi -le 'BEGIN{$base=shift} s/\r//g; s#^\Q$base\E/##' "${1%/*}" <"$2" >"$2"c
		}
		if [[ $1 == $2 ]]; then
			DoubleCheck "$1" "$m3u"
			Clean "$1" "$m3u"
		else
			n3u=$tmpdir/hls.put
			wGetO "$n3u" "$2"
			if ! cmp -s "$m3u" "$n3u"; then
				DoubleCheck "$1" "$m3u"
				DoubleCheck "$2" "$n3u"
			fi
			Clean "$1" "$m3u"
			Clean "$2" "$n3u"
			if ! cmp -s "$m3u"c "$n3u"c; then
				echo >&2 "${0##*/}: URLs provide different playlists"
				set -- "$1" "$1"
			fi
		fi
		# always hash original m3u - segment names can be very simple,
		# it is the directory name that makes the list of segments unique
		hlsdir=$(sha1sum <"$m3u")
		hlsdir=${TMPDIR:-/tmp}/hls-${hlsdir:0:20}
		mkdir -p "$hlsdir"
		cd "$hlsdir"
		if grep '^[^#]' "$m3u"c >$tmpdir/parts; then
			wGetParts "${1%/*}" "${2%/*}"
		fi
		perl -pe 's#^\w+://.*/##' "$m3u"c >.m3u
		OUT=$PWD/.m3u
	else
		# downloaded something else, will return it within tmpdir
		OUT=$m3u
	fi
	rc=
	"${ffmpeg[@]}" -v error -stats -i "$OUT" -f null - &>$tmpdir/fferr || rc=$?
	sed -i 's/\r/\n/g' $tmpdir/fferr
	time=$(sed -n '$s/^\(frame\|size\)=.* time=\([^ ]\+\) .*/\2/p' $tmpdir/fferr)
	sed -i '/^\(frame\|size\)=.* time=/d' $tmpdir/fferr
	tolera='non-existing SPS 0 referenced in buffering period
SPS unavailable in decode_picture_timing
Application provided invalid, non.monotonically increasing dts to muxer
Last message repeated'
	if grep -q -v "$tolera" $tmpdir/fferr; then
		echo >&2 "${0##*/}: rechecking"
	elif [ -n "$rc" ]; then
		# too bad, ffmpeg fails even without -xerror,
		# and we don't have any errors to recheck
		cat $tmpdir/fferr
		echo "${0##*/}: cannot proceed"
		return 1
	else
		return 0
	fi >&2
	if [ "$(head -c7 "$m3u")" = '#EXTM3U' ]; then
		local n=0
		while read -r part; do
			f=${part##*/}
			if ! [ -s "$f" ]; then
				echo >&2 "${0##*/}: missing $f (cannot happen)"
				false
			fi
			"${ffmpeg[@]}" -v error -i "$f" -f null - 2>&1 </dev/null |
				stdbuf -oL sed "s|\t| |g;s|^|$part\t|" &
			(( ++n < 2 )) || wait -n
		done <$tmpdir/parts >$tmpdir/parts.all-errors
		wait
		# if some error is encountered in more than half of the parts,
		# it's not a real error
		perl -pi -e 's/ @ 0x[0-9a-f]+\]/]/' $tmpdir/parts.all-errors
		sort -t$'\t' -u -k2,2 -k1,1 -o $tmpdir/parts.all-errors{,}
		cut -f2 $tmpdir/parts.all-errors |uniq -c |
			awk -v n=$n '(n==1||$1<=n/2){sub(" +[0-9]+ ","");print}' |
			sort -u >$tmpdir/parts.real-errors
		join -t$'\t' -12 -21 -o 1.1 $tmpdir/parts.{all,real}-errors >$tmpdir/parts.ck
		sort -u -o $tmpdir/parts.ck{,}
		while read -r part; do
			f=${part##*/}
			DoubleCheck "$part" "$f" </dev/null
		done <$tmpdir/parts.ck
	else
		DoubleCheck "$url" "$m3u"
	fi
	rc=
	"${ffmpeg[@]}" -xerror -v error -stats -i "$OUT" -f null - &>$tmpdir/fferr || rc=$?
	sed -i 's/\r/\n/g' $tmpdir/fferr
	time=$(sed -n '$s/^\(frame\|size\)=.* time=\([^ ]\+\) .*/\2/p' $tmpdir/fferr)
	sed -i '/^\(frame\|size\)=.* time=/d' $tmpdir/fferr
	# stream still corrupted?
	if grep -v "$tolera" $tmpdir/fferr; then
		echo "${0##*/}: cannot proceed"
		return 1
	elif [ -n "$rc" ]; then
		cat $tmpdir/fferr
		echo "${0##*/}: cannot proceed"
		return 1
	fi >&2
}

wGetHLS "${1:?}" "${2:-$1}" >&2
# returning something within tmpdir?
[ -n "$hlsdir" ] || trap - EXIT
echo "${time:-N/A}" "${OUT:?}"
