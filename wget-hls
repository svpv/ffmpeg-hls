#!/bin/bash -efu

wGetO()
{
	wget=("$av0dir"/wget-progress "$1" wget)
	wopt=(--timeout 20 --tries 3)
	if ! { "${wget[@]}" "${wopt[@]}" -q -O "$@" && [ -s "$1" ]; }; then
		if [ -n "${http_proxy-}" ]; then
			update-uk-proxy --hls --force
			. uk_proxy.sh
		fi
		if ! "${wget[@]}" "${wopt[@]}" -nv -O "$@" &>$tmpdir/werr; then
			cat >&2 $tmpdir/werr
			return 1
		fi
		if ! [ -s "$1" ]; then
			echo >&2 "empty wget output"
			return 1
		fi
	fi
}

DoubleCheck()
{
	local url="$1"; shift
	set -- "$1" $tmpdir/out{1,2}
	wGetO "$2" "$url"
	if cmp -s "$1" "$2"; then
		rm "$2"
	else
		wGetO "$3" "$url"
		if cmp -s "$1" "$3"; then
			rm "$2" "$3"
		elif cmp -s "$2" "$3"; then
			echo >&2 "${0##*/}: fixed $1"
			mv "$2" "$1"
			rm "$3"
		else
			echo >&2 "${0##*/}: cannot fix $1"
			rm "$1" "$2" "$3"
			false
		fi
	fi
}

remove_tmpdir()
{
	rm -r "$tmpdir"
	exit $1
}

tmpdir=$(mktemp -dt "${0##*/}.XXXXXXXX")
trap 'exit 143' HUP INT QUIT PIPE TERM
trap 'remove_tmpdir $?' EXIT

av0=$(readlink -ev "$0")
av0dir=$(dirname "$av0")

wGetStats()
{
	local n
	n=$(wc -l <$tmpdir/parts)
	set +f
	while :; do
		set -- *
		if [ "$*" = "*" ]; then
			set --
		fi
		printf '\r%s %*d/%d ' "${PWD##*/}" ${#n} $# $n
		sleep 1
	done
}

UpdateProxyArgs()
{
	file= args=()
	if [ $1 = --force ]; then
		args+=(--not-proxy=$http_proxy)
		shift
	fi
	local p=$1 loop=$2; shift 2
	local q f=uk_proxy.sh
	for q; do
		if [ $q -gt 1 ]; then
			f=uk_proxy$q.sh
		fi
		if [ $p = $q ]; then
			file=$f
			args+=(--file=$f)
			$loop
		else
			args+=(--not-file=$f)
		fi
	done
}

UpdateKidProxy()
{
	if [ -n "${http_proxy-}" ]; then
		local file args
		UpdateProxyArgs "$@"
		args+=(--hls --recheck)
		until update-uk-proxy "${args[@]}"; do : recheck; done
		. "$file"
	fi
}

EOF()
{
	perl -e 'exit(tell STDIN == -s STDIN ? 0 : 1)'
}

ParaTry()
{
	local b1=$1 b2=$2; shift 2
	# launch kids
	local p b pids= pid2no=()
	for p; do
		UpdateKidProxy $p "break" "$@" </dev/null
		# use either $b1 or $b2 as base URL
		b=b$((1+($p-1)%2))
		"$av0dir"/wget-parts "${!b}" <&0 &
		pids="$pids $! "
		pid2no[$!]=$p
	done
	# wait and possibly relaunch kids
	while [ -n "$pids" ]; do
		local pid= pidrc=
		wait -n || pidrc=$?
		# find out who exited, namely its $p (parallel job no)
		p=
		# also make the list of pids for the next iteration
		local lspids nextpids=
		lspids=$(jobs -p |perl -p0e 's/^/\n/;s/$/\n/;s/\n+/ /g')
		for pid in $pids; do
			case $lspids in
				*" $pid "*) nextpids="$nextpids $pid " ;;
				*) [ -z "$p" ] && p=${pid2no[$pid]} && unset pid2no[$pid] ||
				   echo >&2 "${0##*/}: two pids exited (cannot happen)" ;;
			esac
		done
		pids=$nextpids
		if [ -z "$p" ]; then
			echo >&2 "${0##*/}: don't know who exited (cannot happen)"
			continue
		fi
		# a kid exited successfully? no need to relaunch
		if [ -z "$pidrc" ]; then
			continue
		fi
		# it's an error by now - note that the kids read from stdin
		# and cannot possibly "succeed" after restart
		rc=1
		# 404 Not Found aborts the try
		if [ "$pidrc" = 4 ]; then
			for pid in $nextpids; do
				kill $pid
				wait $pid ||:
			done
			rc=4
			return
		fi
		# will not restart at EOF
		if EOF; then
			continue
		fi
		# relaunch the kid
		local force=
		if [ $pidrc = 3 ]; then
			force=--force
		fi
		UpdateKidProxy $force $p ":" "$@" </dev/null
		b=b$((1+($p-1)%2))
		"$av0dir"/wget-parts "${!b}" <&0 &
		pids="$pids $! "
		pid2no[$!]=$p
	done
}

wGetParts()
{
	wGetStats &
	local try rc=
	local npara=2
	for try in {1..3}; do
		left=$(comm -23 <(perl -pe 's#^\w+://.*/##' $tmpdir/parts |sort) <(ls) |wc -l)
		if [ $left = 0 ]; then
			break
		elif [ $left -lt $npara ]; then
			npara=$left
		fi
		rc=
		local para=$(seq 1 $npara)
		ParaTry "$1" "$2" ${para:?} <$tmpdir/parts
		if [ -z "$rc" ]; then
			break
		fi
		# rotate base URLs
		set -- "$2" "$1"
	done
	kill %1
	wait
	return $rc
}

OUT=
time=
hlsdir=
hlsdirprefix=
ffmpeg=(nice -5 ffmpeg)

CleanLogTime()
{
	sed -i 's/\r/\n/g' "$1"
	sed -ni '/\w/p' "$1"
	time=$(sed -n '$s/^\(frame\|size\)=.* time=\([^ ]\+\) .*/\2/p' "$1")
	sed -i '/^\(frame\|size\)=.* time=/d' $1
}

wGetHLS()
{
	m3u=$tmpdir/hls.out
	wGetO "$m3u" "$1"
	if [ "$(head -c7 "$m3u")" = '#EXTM3U' ]; then
		Clean()
		{
	perl -pi -e 's/\r/\n/g' "$2"
	perl -ni -le 'print if /^#EXT/ or /^[^#]/' "$2"
	perl -pe 'BEGIN{$base=shift} s#^\Q$base\E/##' "${1%/*}" <"$2" >"$2"c
		}
		if [[ $1 == $2 ]]; then
			DoubleCheck "$1" "$m3u"
			Clean "$1" "$m3u"
		else
			n3u=$tmpdir/hls.put
			wGetO "$n3u" "$2"
			if ! cmp -s "$m3u" "$n3u"; then
				DoubleCheck "$1" "$m3u"
				DoubleCheck "$2" "$n3u"
			fi
			Clean "$1" "$m3u"
			Clean "$2" "$n3u"
			if ! cmp -s "$m3u"c "$n3u"c; then
				echo >&2 "${0##*/}: URLs provide different playlists"
				set -- "$1" "$1"
			fi
		fi
		# always hash original m3u - segment names can be very simple,
		# it is the directory name that makes the list of segments unique
		hlsdir=$(sha1sum <"$m3u")
		hlsdir=$hlsdirprefix-${hlsdir:0:20}
		mkdir -p "$hlsdir"
		cd "$hlsdir"
		if grep '^[^#]' "$m3u"c >$tmpdir/parts; then
			wGetParts "${1%/*}" "${2%/*}"
		fi
		perl -pe 's|^[^#].*/||' "$m3u"c >.m3u
		OUT=$PWD/.m3u
	else
		# downloaded something else, will return it within tmpdir
		OUT=$m3u
	fi
	rc=
	"${ffmpeg[@]}" -v warning -stats -i "$OUT" -f null - &>$tmpdir/fferr || rc=$?
	CleanLogTime $tmpdir/fferr
	tolera='non-existing SPS 0 referenced in buffering period
SPS unavailable in decode_picture_timing
Application provided invalid, non.monotonically increasing dts to muxer
Last message repeated'
	if grep -q -v "$tolera" $tmpdir/fferr; then
		echo >&2 "${0##*/}: rechecking"
	elif [ -n "$rc" ]; then
		# too bad, ffmpeg fails even without -xerror,
		# and we don't have any errors to recheck
		cat $tmpdir/fferr
		echo "${0##*/}: cannot proceed"
		return 1
	else
		return 0
	fi >&2
	if [ "$(head -c7 "$m3u")" = '#EXTM3U' ]; then
		local n=0
		while read -r part; do
			f=${part##*/}
			if ! [ -s "$f" ]; then
				echo >&2 "${0##*/}: missing $f (cannot happen)"
				false
			fi
			"${ffmpeg[@]}" -v warning -i "$f" -f null - 2>&1 </dev/null |
				stdbuf -oL sed "s|\t| |g;s|^|${part//|/\\|}\t|" &
			(( ++n < 2 )) || wait -n
		done <$tmpdir/parts >$tmpdir/parts.all-errors
		wait
		# if some error is encountered in more than half of the parts,
		# it's not a real error
		perl -pi -e 's/ @ 0x[0-9a-f]+\]/]/' $tmpdir/parts.all-errors
		sort -t$'\t' -u -k2,2 -k1,1 -o $tmpdir/parts.all-errors{,}
		cut -f2 $tmpdir/parts.all-errors |uniq -c |
			awk -v n=$n '(n==1||$1<=n/2){sub(" +[0-9]+ ","");print}' |
			sort -u >$tmpdir/parts.real-errors
		join -t$'\t' -12 -21 -o 1.1 $tmpdir/parts.{all,real}-errors >$tmpdir/parts.ck
		sort -u -o $tmpdir/parts.ck{,}
		while read -r part; do
			f=${part##*/}
			DoubleCheck "$part" "$f" </dev/null
		done <$tmpdir/parts.ck
	else
		DoubleCheck "$1" "$m3u"
	fi
	rc=
	"${ffmpeg[@]}" -xerror -v warning -stats -i "$OUT" -f null - &>$tmpdir/fferr || rc=$?
	CleanLogTime $tmpdir/fferr
	# stream still corrupted?
	if grep -v "$tolera" $tmpdir/fferr; then
		echo "${0##*/}: cannot proceed"
		return 1
	elif [ -n "$rc" ]; then
		cat $tmpdir/fferr
		echo "${0##*/}: cannot proceed"
		return 1
	fi >&2
}

if [[ ${1:?} = --name=* ]]; then
	hlsdirprefix=${1#--name=}
	shift
fi

case $hlsdirprefix in
	*/*) ;;
	 '') hlsdirprefix=${TMPDIR:-/tmp}/hls ;;
	  *) hlsdirprefix=${TMPDIR:-/tmp}/hls-$hlsdirprefix ;;
esac

wGetHLS "${1:?}" "${2:-$1}" >&2
# returning something within tmpdir?
[ -n "$hlsdir" ] || trap - EXIT
echo "${time:?}" "${OUT:?}"
