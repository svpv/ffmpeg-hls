#!/bin/bash -efu

wGetO()
{
	wget=("$av0dir"/wget-progress "$1" wget)
	wopt=(--timeout 20 --tries 3)
	if ! { "${wget[@]}" "${wopt[@]}" -q -O "$@" && [ -s "$1" ]; }; then
		if [ -n "${http_proxy-}" ]; then
			update-uk-proxy --hls
			. uk_proxy.sh
		fi
		if ! "${wget[@]}" "${wopt[@]}" -nv -O "$@" &>$tmpdir/werr; then
			cat >&2 $tmpdir/werr
			return 1
		fi
		if ! [ -s "$1" ]; then
			echo >&2 "empty wget output"
			return 1
		fi
	fi
}

DoubleCheck()
{
	local url="$1"; shift
	set -- "$1" $tmpdir/out{1,2}
	wGetO "$2" "$url"
	if cmp -s "$1" "$2"; then
		rm "$2"
	else
		wGetO "$3" "$url"
		if cmp -s "$1" "$3"; then
			rm "$2" "$3"
		elif cmp -s "$2" "$3"; then
			echo >&2 "${0##*/}: fixed $1"
			mv "$2" "$1"
			rm "$3"
		else
			echo >&2 "${0##*/}: cannot fix $1"
			rm "$1" "$2" "$3"
			false
		fi
	fi
}

remove_tmpdir()
{
	rm -r "$tmpdir"
	exit $1
}

tmpdir=$(mktemp -dt "${0##*/}.XXXXXXXX")
trap 'exit 143' HUP INT QUIT PIPE TERM
trap 'remove_tmpdir $?' EXIT

av0=$(readlink -ev "$0")
av0dir=$(dirname "$av0")

wGetStats()
{
	local n
	n=$(wc -l <$tmpdir/parts)
	set +f
	while :; do
		set -- *
		if [ "$*" = "*" ]; then
			set --
		fi
		printf '\r%s %*d/%d ' "${PWD##*/}" ${#n} $# $n
		sleep 1
	done
}

UpdateProxyArgs()
{
	file= excl=()
	local p=$1 loop=$2; shift 2
	local q f=uk_proxy.sh
	for q; do
		if [ $q -gt 1 ]; then
			f=uk_proxy$q.sh
		fi
		if [ $p = $q ]; then
			file=$f
			$loop
		else
			excl+=(--not-file=$f)
		fi
	done
}

UpdateKidProxy()
{
	if [ -n "${http_proxy-}" ]; then
		local file excl
		UpdateProxyArgs "$@"
		update-uk-proxy --hls --file=$file ${excl[@]} ||
		update-uk-proxy --hls --file=$file ${excl[@]} ||
		until update-uk-proxy --file=$file --hls; do :; done
		. "$file"
	fi
}

EOF()
{
	perl -e 'exit(tell STDIN == -s STDIN ? 0 : 1)'
}

Try1()
{
	local p="$1" b="$2"; shift 2
	"$av0dir"/wget-parts "$b" && return
	while :; do
		EOF && break
		UpdateKidProxy $p ":" "$@" </dev/null
		EOF && break
		"$av0dir"/wget-parts "$b" && break
	done
	return 1
}

ParaTry()
{
	local b1=$1 b2=$2; shift 2
	local p b pids=
	for p; do
		UpdateKidProxy $p "break" "$@" </dev/null
		# use either $b1 or $b2 as base URL
		b=b$((1+($p-1)%2))
		Try1 $p "${!b}" "$@" <&0 &
		pids="$pids $!"
	done
	for p in $pids; do
		wait $p || rc=1
	done
}

wGetParts()
{
	wGetStats &
	local try rc=
	local npara=2
	for try in {1..3}; do
		left=$(comm -23 <(perl -pe 's#^\w+://.*/##' $tmpdir/parts |sort) <(ls) |wc -l)
		if [ $left = 0 ]; then
			break
		elif [ $left -lt $npara ]; then
			npara=$left
		fi
		rc=
		local para=$(seq 1 $npara)
		ParaTry "$1" "$2" ${para:?} <$tmpdir/parts
		if [ -z "$rc" ]; then
			break
		fi
		# rotate base URLs
		set -- "$2" "$1"
	done
	kill %1
	wait
	return $rc
}

OUT=
time=
hlsdir=
hlsdirprefix=
ffmpeg=(nice -5 ffmpeg)

CleanLogTime()
{
	sed -i 's/\r/\n/g' "$1"
	sed -ni '/\w/p' "$1"
	time=$(sed -n '$s/^\(frame\|size\)=.* time=\([^ ]\+\) .*/\2/p' "$1")
	sed -i '/^\(frame\|size\)=.* time=/d' $1
}

wGetHLS()
{
	m3u=$tmpdir/hls.out
	wGetO "$m3u" "$1"
	if [ "$(head -c7 "$m3u")" = '#EXTM3U' ]; then
		Clean()
		{
	perl -pi -e 's/\r/\n/g' "$2"
	perl -ni -le 'print if /^#EXT/ or /^[^#]/' "$2"
	perl -pe 'BEGIN{$base=shift} s#^\Q$base\E/##' "${1%/*}" <"$2" >"$2"c
		}
		if [[ $1 == $2 ]]; then
			DoubleCheck "$1" "$m3u"
			Clean "$1" "$m3u"
		else
			n3u=$tmpdir/hls.put
			wGetO "$n3u" "$2"
			if ! cmp -s "$m3u" "$n3u"; then
				DoubleCheck "$1" "$m3u"
				DoubleCheck "$2" "$n3u"
			fi
			Clean "$1" "$m3u"
			Clean "$2" "$n3u"
			if ! cmp -s "$m3u"c "$n3u"c; then
				echo >&2 "${0##*/}: URLs provide different playlists"
				set -- "$1" "$1"
			fi
		fi
		# always hash original m3u - segment names can be very simple,
		# it is the directory name that makes the list of segments unique
		hlsdir=$(sha1sum <"$m3u")
		hlsdir=$hlsdirprefix-${hlsdir:0:20}
		mkdir -p "$hlsdir"
		cd "$hlsdir"
		if grep '^[^#]' "$m3u"c >$tmpdir/parts; then
			wGetParts "${1%/*}" "${2%/*}"
		fi
		perl -pe 's|^[^#].*/||' "$m3u"c >.m3u
		OUT=$PWD/.m3u
	else
		# downloaded something else, will return it within tmpdir
		OUT=$m3u
	fi
	rc=
	"${ffmpeg[@]}" -v warning -stats -i "$OUT" -f null - &>$tmpdir/fferr || rc=$?
	CleanLogTime $tmpdir/fferr
	tolera='non-existing SPS 0 referenced in buffering period
SPS unavailable in decode_picture_timing
Application provided invalid, non.monotonically increasing dts to muxer
Invalid timestamps stream=
Last message repeated'
	if grep -q -v "$tolera" $tmpdir/fferr; then
		echo >&2 "${0##*/}: rechecking"
	elif [ -n "$rc" ]; then
		# too bad, ffmpeg fails even without -xerror,
		# and we don't have any errors to recheck
		cat $tmpdir/fferr
		echo "${0##*/}: cannot proceed"
		return 1
	else
		return 0
	fi >&2
	if [ "$(head -c7 "$m3u")" = '#EXTM3U' ]; then
		local n=0
		while read -r part; do
			f=${part##*/}
			if ! [ -s "$f" ]; then
				echo >&2 "${0##*/}: missing $f (cannot happen)"
				false
			fi
			"${ffmpeg[@]}" -v warning -i "$f" -f null - 2>&1 </dev/null |
				stdbuf -oL sed "s|\t| |g;s|^|${part//|/\\|}\t|" &
			(( ++n < 2 )) || wait -n
		done <$tmpdir/parts >$tmpdir/parts.all-errors
		wait
		# if some error is encountered in more than half of the parts,
		# it's not a real error
		perl -pi -e 's/ @ 0x[0-9a-f]+\]/]/' $tmpdir/parts.all-errors
		perl -pi -e 's/\b(pts|dts|size)=\d+\b/$1=42/g' $tmpdir/parts.all-errors
		perl -pi -e 's/\b(dts to muxer in stream \d): \d+ >= \d+/$1/' $tmpdir/parts.all-errors
		sort -t$'\t' -u -k2,2 -k1,1 -o $tmpdir/parts.all-errors{,}
		cut -f2 $tmpdir/parts.all-errors |uniq -c |
			awk -v n=$n '(n==1||$1<=n/2){sub(" +[0-9]+ ","");print}' |
			sort -u >$tmpdir/parts.real-errors
		join -t$'\t' -12 -21 -o 1.1 $tmpdir/parts.{all,real}-errors >$tmpdir/parts.ck
		sort -u -o $tmpdir/parts.ck{,}
		echo >&2 "${0##*/}: $(wc -l <$tmpdir/parts.ck) parts to recheck"
		while read -r part; do
			f=${part##*/}
			[[ $part = *://* ]] || part=${1%/*}/$part
			DoubleCheck "$part" "$f" </dev/null
		done <$tmpdir/parts.ck
	else
		DoubleCheck "$1" "$m3u"
	fi
	rc=
	"${ffmpeg[@]}" -xerror -v warning -stats -i "$OUT" -f null - &>$tmpdir/fferr || rc=$?
	CleanLogTime $tmpdir/fferr
	# stream still corrupted?
	if grep -v "$tolera" $tmpdir/fferr; then
		echo "${0##*/}: cannot proceed"
		return 1
	elif [ -n "$rc" ]; then
		cat $tmpdir/fferr
		echo "${0##*/}: cannot proceed"
		return 1
	fi >&2
}

if [[ ${1:?} = --name=* ]]; then
	hlsdirprefix=${1#--name=}
	shift
fi

case $hlsdirprefix in
	*/*) ;;
	 '') hlsdirprefix=${TMPDIR:-/tmp}/hls ;;
	  *) hlsdirprefix=${TMPDIR:-/tmp}/hls-$hlsdirprefix ;;
esac

wGetHLS "${1:?}" "${2:-$1}" </dev/null >&2
# returning something within tmpdir?
[ -n "$hlsdir" ] || trap - EXIT
echo "${time:?}" "${OUT:?}"
